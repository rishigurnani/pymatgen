<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pymatgen.io.abinit.strategies &#8212; pymatgen 2017.6.8 documentation</title>
    
    <link rel="stylesheet" href="../../../../_static/proBlue.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../',
        VERSION:     '2017.6.8',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
 
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-33990148-1']);
  _gaq.push(['_trackPageview']);
</script>

  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">pymatgen 2017.6.8 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../../pymatgen.html" accesskey="U">pymatgen</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pymatgen.io.abinit.strategies</h1><div class="highlight"><pre>
<span></span><span class="c1"># coding: utf-8</span>
<span class="c1"># Copyright (c) Pymatgen Development Team.</span>
<span class="c1"># Distributed under the terms of the MIT License.</span>
<span class="sd">&quot;&quot;&quot;Strategy objects for creating ABINIT calculations.&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">unicode_literals</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">six</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">six.moves</span> <span class="k">import</span> <span class="nb">map</span><span class="p">,</span> <span class="nb">zip</span>
<span class="kn">from</span> <span class="nn">monty.string</span> <span class="k">import</span> <span class="n">is_string</span>
<span class="kn">from</span> <span class="nn">monty.json</span> <span class="k">import</span> <span class="n">MontyEncoder</span><span class="p">,</span> <span class="n">MontyDecoder</span>
<span class="kn">from</span> <span class="nn">monty.dev</span> <span class="k">import</span> <span class="n">deprecated</span>
<span class="kn">from</span> <span class="nn">pymatgen.util.string</span> <span class="k">import</span> <span class="n">str_delimited</span>
<span class="kn">from</span> <span class="nn">.abiobjects</span> <span class="k">import</span> <span class="n">Electrons</span>
<span class="kn">from</span> <span class="nn">.pseudos</span> <span class="k">import</span> <span class="n">PseudoTable</span><span class="p">,</span> <span class="n">Pseudo</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;Matteo Giantomassi&quot;</span>
<span class="n">__copyright__</span> <span class="o">=</span> <span class="s2">&quot;Copyright 2013, The Materials Project&quot;</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="s2">&quot;0.1&quot;</span>
<span class="n">__maintainer__</span> <span class="o">=</span> <span class="s2">&quot;Matteo Giantomassi&quot;</span>
<span class="n">__email__</span> <span class="o">=</span> <span class="s2">&quot;gmatteo at gmail.com&quot;</span>


<div class="viewcode-block" id="num_valence_electrons"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.strategies.html#pymatgen.io.abinit.strategies.num_valence_electrons">[docs]</a><span class="k">def</span> <span class="nf">num_valence_electrons</span><span class="p">(</span><span class="n">pseudos</span><span class="p">,</span> <span class="n">structure</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the number of valence electrons from</span>
<span class="sd">    a list of pseudopotentials and the crystalline structure.</span>

<span class="sd">    Args:</span>
<span class="sd">        pseudos: List of strings, list of of pseudos or `PseudoTable` instance.</span>
<span class="sd">        structure: Pymatgen structure.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError if cannot find a pseudo in the input pseudos or if the</span>
<span class="sd">        input list contains more than one pseudo for the chemical symbols appearing in structure.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">table</span> <span class="o">=</span> <span class="n">PseudoTable</span><span class="o">.</span><span class="n">as_table</span><span class="p">(</span><span class="n">pseudos</span><span class="p">)</span>

    <span class="n">valence</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">structure</span><span class="p">:</span>
        <span class="n">entries</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">pseudos_with_symbol</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="o">.</span><span class="n">symbol</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">entries</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Found </span><span class="si">%d</span><span class="s2"> entries for symbol </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">entries</span><span class="p">),</span> <span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="o">.</span><span class="n">symbol</span><span class="p">))</span>
        <span class="n">valence</span> <span class="o">+=</span> <span class="n">entries</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">Z_val</span>

    <span class="k">return</span> <span class="n">valence</span></div>


<span class="c1">#class AbstractStrategy(six.with_metaclass(abc.ABCMeta, object)):</span>
<span class="c1">#    &quot;&quot;&quot;</span>
<span class="c1">#    A Strategy object generates the ABINIT input file used for a particular type of calculation</span>
<span class="c1">#    e.g. ground-state runs, structural relaxations, self-energy calculations ...</span>
<span class="c1">#</span>
<span class="c1">#    A Strategy can absorb data (e.g. data produced in the previous steps of a workflow) and</span>
<span class="c1">#    can use this piece of information to generate/optimize the input variables.</span>
<span class="c1">#    Strategy objects must provide the method make_input that builds and returns the abinit input file.</span>
<span class="c1">#</span>
<span class="c1">#    Attributes:</span>
<span class="c1">#</span>
<span class="c1">#        pseudos: List of pseudopotentials.</span>
<span class="c1">#    &quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#    #@abc.abstractproperty</span>
<span class="c1">#    #def pseudos(self):</span>
<span class="c1">#</span>
<span class="c1">#    @property</span>
<span class="c1">#    def isnc(self):</span>
<span class="c1">#        &quot;&quot;&quot;True if norm-conserving calculation.&quot;&quot;&quot;</span>
<span class="c1">#        return all(p.isnc for p in self.pseudos)</span>
<span class="c1">#</span>
<span class="c1">#    @property</span>
<span class="c1">#    def ispaw(self):</span>
<span class="c1">#        &quot;&quot;&quot;True if PAW calculation.&quot;&quot;&quot;</span>
<span class="c1">#        return all(p.ispaw for p in self.pseudos)</span>
<span class="c1">#</span>
<span class="c1">#    def num_valence_electrons(self):</span>
<span class="c1">#        &quot;&quot;&quot;Number of valence electrons computed from the pseudos and the structure.&quot;&quot;&quot;</span>
<span class="c1">#        return num_valence_electrons(self.pseudos, self.structure)</span>
<span class="c1">#</span>
<span class="c1">#    @abc.abstractproperty</span>
<span class="c1">#    def structure(self):</span>
<span class="c1">#        &quot;&quot;&quot;Structure object&quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#    #def set_structure(self, structure):</span>
<span class="c1">#    #    self.structure = structure</span>
<span class="c1">#</span>
<span class="c1">#    #def change_structure(self, structure):</span>
<span class="c1">#    #    self.structure = structure</span>
<span class="c1">#</span>
<span class="c1">#    #def to_abivars(self):</span>
<span class="c1">#    #def to_dict(self):</span>
<span class="c1">#    #def from_abivars(cls, d):</span>
<span class="c1">#    #def from_dict(self, d):</span>
<span class="c1">#</span>
<span class="c1">#    def copy(self):</span>
<span class="c1">#        &quot;&quot;&quot;Shallow copy of self.&quot;&quot;&quot;</span>
<span class="c1">#        return copy.copy(self)</span>
<span class="c1">#</span>
<span class="c1">#    def deepcopy(self):</span>
<span class="c1">#        &quot;&quot;&quot;Deep copy of self.&quot;&quot;&quot;</span>
<span class="c1">#        return copy.deepcopy(self)</span>
<span class="c1">#</span>
<span class="c1">#    @abc.abstractmethod</span>
<span class="c1">#    def make_input(self, *args, **kwargs):</span>
<span class="c1">#        &quot;&quot;&quot;Returns an Input instance.&quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#class StrategyWithInput(object):</span>
<span class="c1">#    # TODO: Find a better way to do this. I will likely need to refactor the Strategy object</span>
<span class="c1">#    def __init__(self, abinit_input, deepcopy=True):</span>
<span class="c1">#        if deepcopy: abinit_input = copy.deepcopy(abinit_input)</span>
<span class="c1">#        self.abinit_input = abinit_input</span>
<span class="c1">#</span>
<span class="c1">#    @property</span>
<span class="c1">#    def pseudos(self):</span>
<span class="c1">#        # FIXME: pseudos must be order but I need to define an ABC for the Strategies and Inputs.</span>
<span class="c1">#        # Order pseudos</span>
<span class="c1">#        return self.abinit_input.pseudos</span>
<span class="c1">#</span>
<span class="c1">#    @property</span>
<span class="c1">#    def structure(self):</span>
<span class="c1">#        return self.abinit_input.structure</span>
<span class="c1">#</span>
<span class="c1">#    @structure.setter</span>
<span class="c1">#    def structure(self, structure):</span>
<span class="c1">#        self.abinit_input.set_structure(structure)</span>
<span class="c1">#</span>
<span class="c1">#    def add_extra_abivars(self, abivars):</span>
<span class="c1">#        &quot;&quot;&quot;Add variables (dict) to extra_abivars.&quot;&quot;&quot;</span>
<span class="c1">#        self.abinit_input.set_vars(**abivars)</span>
<span class="c1">#</span>
<span class="c1">#    def remove_extra_abivars(self, keys):</span>
<span class="c1">#        &quot;&quot;&quot;Remove variables from extra_abivars.&quot;&quot;&quot;</span>
<span class="c1">#        self.abinit_input.remove_vars(keys)</span>
<span class="c1">#</span>
<span class="c1">#    def make_input(self):</span>
<span class="c1">#        return str(self.abinit_input)</span>
<span class="c1">#</span>
<span class="c1">#    def deepcopy(self):</span>
<span class="c1">#        &quot;&quot;&quot;Deep copy of self.&quot;&quot;&quot;</span>
<span class="c1">#        return copy.deepcopy(self)</span>
<span class="c1">#</span>
<span class="c1">#    def as_dict(self):</span>
<span class="c1">#        d = {&#39;abinit_input&#39;: self.abinit_input.as_dict()}</span>
<span class="c1">#        d[&quot;@module&quot;] = self.__class__.__module__</span>
<span class="c1">#        d[&quot;@class&quot;] = self.__class__.__name__</span>
<span class="c1">#        return d</span>
<span class="c1">#</span>
<span class="c1">#    @classmethod</span>
<span class="c1">#    def from_dict(cls, d):</span>
<span class="c1">#        abinit_input = d[&#39;abinit_input&#39;]</span>
<span class="c1">#        modname = abinit_input[&quot;@module&quot;]</span>
<span class="c1">#        classname = abinit_input[&quot;@class&quot;]</span>
<span class="c1">#        mod = __import__(modname, globals(), locals(), [classname], 0)</span>
<span class="c1">#        cls_ = getattr(mod, classname)</span>
<span class="c1">#        strategy = cls(cls_.from_dict(abinit_input))</span>
<span class="c1">#        return strategy</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#class HtcStrategy(AbstractStrategy):</span>
<span class="c1">#    &quot;&quot;&quot;</span>
<span class="c1">#    Attributes:</span>
<span class="c1">#</span>
<span class="c1">#        accuracy: Accuracy of the calculation used to define basic parameters of the run.</span>
<span class="c1">#            such as tolerances, basis set truncation ...</span>
<span class="c1">#    &quot;&quot;&quot;</span>
<span class="c1">#    __metaclass__ = abc.ABCMeta</span>
<span class="c1">#</span>
<span class="c1">#    # Mapping runlevel --&gt; optdriver variable</span>
<span class="c1">#    _runl2optdriver = {</span>
<span class="c1">#        &quot;scf&quot;: 0,</span>
<span class="c1">#        &quot;nscf&quot;: 0,</span>
<span class="c1">#        &quot;relax&quot;: 0,</span>
<span class="c1">#        &quot;dfpt&quot;: 1,</span>
<span class="c1">#        &quot;screening&quot;: 3,</span>
<span class="c1">#        &quot;sigma&quot;: 4,</span>
<span class="c1">#        &quot;bse&quot;: 99,</span>
<span class="c1">#    }</span>
<span class="c1">#</span>
<span class="c1">#    # Name of the (default) tolerance used by the runlevels.</span>
<span class="c1">#    _runl2tolname = {</span>
<span class="c1">#        &quot;scf&quot;: &#39;tolvrs&#39;,</span>
<span class="c1">#        &quot;nscf&quot;: &#39;tolwfr&#39;,</span>
<span class="c1">#        &quot;dfpt&quot;: &#39;toldfe&#39;,        # ?</span>
<span class="c1">#        &quot;screening&quot;: &#39;toldfe&#39;,   # dummy</span>
<span class="c1">#        &quot;sigma&quot;: &#39;toldfe&#39;,       # dummy</span>
<span class="c1">#        &quot;bse&quot;: &#39;toldfe&#39;,         # ?</span>
<span class="c1">#        &quot;relax&quot;: &#39;tolrff&#39;,</span>
<span class="c1">#    }</span>
<span class="c1">#</span>
<span class="c1">#    # Tolerances for the different levels of accuracy.</span>
<span class="c1">#    T = collections.namedtuple(&#39;Tolerance&#39;, &quot;low normal high&quot;)</span>
<span class="c1">#    _tolerances = {</span>
<span class="c1">#        &quot;toldfe&quot;: T(1.e-7,  1.e-8,  1.e-9),</span>
<span class="c1">#        &quot;tolvrs&quot;: T(1.e-7,  1.e-8,  1.e-9),</span>
<span class="c1">#        &quot;tolwfr&quot;: T(1.e-15, 1.e-17, 1.e-19),</span>
<span class="c1">#        &quot;tolrff&quot;: T(0.04,   0.02,   0.01)}</span>
<span class="c1">#    del T</span>
<span class="c1">#</span>
<span class="c1">#    def __repr__(self):</span>
<span class="c1">#        return &quot;&lt;%s at %s, accuracy = %s&gt;&quot; % (self.__class__.__name__, id(self), self.accuracy)</span>
<span class="c1">#</span>
<span class="c1">#    @abc.abstractproperty</span>
<span class="c1">#    def runlevel(self):</span>
<span class="c1">#        &quot;&quot;&quot;String defining the Runlevel. See _runl2optdriver.&quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#    @property</span>
<span class="c1">#    def optdriver(self):</span>
<span class="c1">#        &quot;&quot;&quot;The optdriver associated to the calculation.&quot;&quot;&quot;</span>
<span class="c1">#        return self._runl2optdriver[self.runlevel]</span>
<span class="c1">#</span>
<span class="c1">#    def learn(self, **data):</span>
<span class="c1">#        &quot;&quot;&quot;Update the data stored in self.&quot;&quot;&quot;</span>
<span class="c1">#        if not hasattr(self, &quot;_data&quot;):</span>
<span class="c1">#            self._data = dict(data)</span>
<span class="c1">#        else:</span>
<span class="c1">#            if [k in self._data for k in data].count(True) != 0:</span>
<span class="c1">#                raise ValueError(&quot;Keys %s are already present in data&quot; % str([k for k in data]))</span>
<span class="c1">#            self._data.update(data)</span>
<span class="c1">#</span>
<span class="c1">#    @property</span>
<span class="c1">#    def accuracy(self):</span>
<span class="c1">#        &quot;&quot;&quot;Accuracy used by the strategy.&quot;&quot;&quot;</span>
<span class="c1">#        try:</span>
<span class="c1">#            return self._accuracy</span>
<span class="c1">#        except AttributeError:</span>
<span class="c1">#            self.set_accuracy(&quot;normal&quot;)</span>
<span class="c1">#            return self._accuracy</span>
<span class="c1">#</span>
<span class="c1">#    def set_accuracy(self, accuracy):</span>
<span class="c1">#        &quot;&quot;&quot;Accuracy setter.&quot;&quot;&quot;</span>
<span class="c1">#        if hasattr(self, &quot;_accuracy&quot;):</span>
<span class="c1">#            raise RuntimeError(&quot;object already has accuracy %s &quot; % self._accuracy)</span>
<span class="c1">#</span>
<span class="c1">#        assert accuracy in [&quot;low&quot;, &quot;normal&quot;, &quot;high&quot;]</span>
<span class="c1">#        self._accuracy = accuracy</span>
<span class="c1">#</span>
<span class="c1">#    @property</span>
<span class="c1">#    def data(self):</span>
<span class="c1">#        &quot;&quot;&quot;Data absorbed by the strategy during the workflow.&quot;&quot;&quot;</span>
<span class="c1">#        try:</span>
<span class="c1">#            return self. _data</span>
<span class="c1">#        except AttributeError:</span>
<span class="c1">#            return {}</span>
<span class="c1">#</span>
<span class="c1">#    @property</span>
<span class="c1">#    def ecut(self):</span>
<span class="c1">#        &quot;&quot;&quot;Cutoff energy in Hartree.&quot;&quot;&quot;</span>
<span class="c1">#        try:</span>
<span class="c1">#            # User option.</span>
<span class="c1">#            return self.extra_abivars[&quot;ecut&quot;]</span>
<span class="c1">#        except KeyError:</span>
<span class="c1">#            # Compute ecut from the Pseudo Hints.</span>
<span class="c1">#            hints = [p.hint_for_accuracy(self.accuracy) for p in self.pseudos]</span>
<span class="c1">#            return max(hint.ecut for hint in hints)</span>
<span class="c1">#</span>
<span class="c1">#    @property</span>
<span class="c1">#    def pawecutdg(self):</span>
<span class="c1">#        &quot;&quot;&quot;Cutoff energy in Hartree for the dense grid used in PAW calculations.&quot;&quot;&quot;</span>
<span class="c1">#        if not self.ispaw:</span>
<span class="c1">#            return None</span>
<span class="c1">#</span>
<span class="c1">#        try:</span>
<span class="c1">#            # User option.</span>
<span class="c1">#            return self.extra_abivars[&quot;pawecutdg&quot;]</span>
<span class="c1">#        except KeyError:</span>
<span class="c1">#            raise NotImplementedError(&quot;&quot;)</span>
<span class="c1">#            #ratio = max(p.suggested_augratio(accuracy) for p in self.pseudos])</span>
<span class="c1">#            #ratio = augration_high if high else augratio_norm</span>
<span class="c1">#            #pawecutdg = ecut * ratio</span>
<span class="c1">#</span>
<span class="c1">#    @property</span>
<span class="c1">#    def tolerance(self):</span>
<span class="c1">#        &quot;&quot;&quot;Return a dict {varname: varvalue} with the tolerance used for the calculation.&quot;&quot;&quot;</span>
<span class="c1">#        # Check user options first.</span>
<span class="c1">#        for tolname in self._tolerances:</span>
<span class="c1">#            try:</span>
<span class="c1">#                return {tolname: self.extra_abivars[tolname]}</span>
<span class="c1">#            except KeyError:</span>
<span class="c1">#                pass</span>
<span class="c1">#</span>
<span class="c1">#        # Use default values depending on the runlevel and the accuracy.</span>
<span class="c1">#        tolname = self._runl2tolname[self.runlevel]</span>
<span class="c1">#</span>
<span class="c1">#        return {tolname: getattr(self._tolerances[tolname], self.accuracy)}</span>
<span class="c1">#</span>
<span class="c1">#    @property</span>
<span class="c1">#    def need_forces(self):</span>
<span class="c1">#        &quot;&quot;&quot;True if forces are required at each SCF step (like the stresses).&quot;&quot;&quot;</span>
<span class="c1">#        return self.runlevel in [&quot;relax&quot;,]</span>
<span class="c1">#</span>
<span class="c1">#    @property</span>
<span class="c1">#    def need_stress(self):</span>
<span class="c1">#        &quot;&quot;&quot;True if the computation of the stress is required.&quot;&quot;&quot;</span>
<span class="c1">#        # TODO: here it&#39;s easier to check if optcell != 0</span>
<span class="c1">#        return self.runlevel in [&quot;relax&quot;]</span>
<span class="c1">#</span>
<span class="c1">#    def add_extra_abivars(self, abivars):</span>
<span class="c1">#        &quot;&quot;&quot;Add variables (dict) to extra_abivars.&quot;&quot;&quot;</span>
<span class="c1">#        self.extra_abivars.update(abivars)</span>
<span class="c1">#</span>
<span class="c1">#    def remove_extra_abivars(self, keys):</span>
<span class="c1">#        for key in keys:</span>
<span class="c1">#            self.extra_abivars.pop(key)</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#class ScfStrategy(HtcStrategy):</span>
<span class="c1">#    &quot;&quot;&quot;</span>
<span class="c1">#    Strategy for ground-state SCF calculations.</span>
<span class="c1">#    &quot;&quot;&quot;</span>
<span class="c1">#    def __init__(self, structure, pseudos, ksampling, accuracy=&quot;normal&quot;, spin_mode=&quot;polarized&quot;,</span>
<span class="c1">#                 smearing=&quot;fermi_dirac:0.1 eV&quot;, charge=0.0, scf_algorithm=None, use_symmetries=True, **extra_abivars):</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        Args:</span>
<span class="c1">#            structure: pymatgen structure</span>
<span class="c1">#            pseudos: List of pseudopotentials.</span>
<span class="c1">#            ksampling: :class:`Ksampling` object defining the sampling of the BZ.</span>
<span class="c1">#            accuracy: Accuracy of the calculation.</span>
<span class="c1">#            spin_mode: Spin polarization mode.</span>
<span class="c1">#            smearing: string or :class:`Smearing` instance.</span>
<span class="c1">#            charge: Total charge of the system. Default is 0.</span>
<span class="c1">#            scf_algorithm: :class:`ElectronsAlgorithm` instance.</span>
<span class="c1">#            use_symmetries: False if point group symmetries should not be used.</span>
<span class="c1">#            extra_abivars: Extra variables that will be directly added to the input file.</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        super(ScfStrategy, self).__init__()</span>
<span class="c1">#</span>
<span class="c1">#        self.set_accuracy(accuracy)</span>
<span class="c1">#        self._structure = structure</span>
<span class="c1">#</span>
<span class="c1">#        table = PseudoTable.as_table(pseudos)</span>
<span class="c1">#        self.pseudos = table.pseudos_with_symbols(list(structure.composition.get_el_amt_dict().keys()))</span>
<span class="c1">#</span>
<span class="c1">#        self.ksampling = ksampling</span>
<span class="c1">#        self.use_symmetries = use_symmetries</span>
<span class="c1">#</span>
<span class="c1">#        self.electrons = Electrons(spin_mode=spin_mode, smearing=smearing, algorithm=scf_algorithm,</span>
<span class="c1">#                                   nband=None, fband=None, charge=charge)</span>
<span class="c1">#</span>
<span class="c1">#        self.extra_abivars = extra_abivars</span>
<span class="c1">#</span>
<span class="c1">#    @property</span>
<span class="c1">#    def runlevel(self):</span>
<span class="c1">#        return &quot;scf&quot;</span>
<span class="c1">#</span>
<span class="c1">#    @property</span>
<span class="c1">#    def structure(self):</span>
<span class="c1">#        return self._structure</span>
<span class="c1">#</span>
<span class="c1">#    @structure.setter</span>
<span class="c1">#    def structure(self, structure):</span>
<span class="c1">#        self._structure = structure</span>
<span class="c1">#</span>
<span class="c1">#    def _define_extra_params(self):</span>
<span class="c1">#        extra = dict(optdriver=self.optdriver, ecut=self.ecut, pawecutdg=self.pawecutdg)</span>
<span class="c1">#        extra.update(self.tolerance)</span>
<span class="c1">#        extra.update({&quot;nsym&quot;: 1 if not self.use_symmetries else None})</span>
<span class="c1">#        extra.update(self.extra_abivars)</span>
<span class="c1">#        return extra</span>
<span class="c1">#</span>
<span class="c1">#    @deprecated(message=&quot;Strategy objects will be removed in pmg v3.1. Use AbiInput&quot;)</span>
<span class="c1">#    def make_input(self):</span>
<span class="c1">#        extra = self._define_extra_params()</span>
<span class="c1">#</span>
<span class="c1">#        inpw = InputWriter(self.structure, self.electrons, self.ksampling, **extra)</span>
<span class="c1">#        return inpw.get_string()</span>
<span class="c1">#</span>
<span class="c1">#    def as_dict(self):</span>
<span class="c1">#        d = {}</span>
<span class="c1">#        d[&#39;structure&#39;] = self.structure.as_dict()</span>
<span class="c1">#        d[&#39;pseudos&#39;] = [p.as_dict() for p in self.pseudos]</span>
<span class="c1">#        d[&#39;ksampling&#39;] = self.ksampling.as_dict()</span>
<span class="c1">#        d[&#39;accuracy&#39;] = self.accuracy</span>
<span class="c1">#        d[&#39;electrons&#39;] = self.electrons.as_dict()</span>
<span class="c1">#        d[&#39;charge&#39;] = self.electrons.charge</span>
<span class="c1">#        d[&#39;use_symmetries&#39;] = self.use_symmetries</span>
<span class="c1">#        d[&#39;extra_abivars&#39;] = self.extra_abivars</span>
<span class="c1">#        d[&#39;@module&#39;] = self.__class__.__module__</span>
<span class="c1">#        d[&#39;@class&#39;] = self.__class__.__name__</span>
<span class="c1">#</span>
<span class="c1">#        return d</span>
<span class="c1">#</span>
<span class="c1">#    @classmethod</span>
<span class="c1">#    def from_dict(cls, d):</span>
<span class="c1">#        dec = MontyDecoder()</span>
<span class="c1">#        structure = dec.process_decoded(d[&quot;structure&quot;])</span>
<span class="c1">#        pseudos = dec.process_decoded(d[&#39;pseudos&#39;])</span>
<span class="c1">#        ksampling = dec.process_decoded(d[&quot;ksampling&quot;])</span>
<span class="c1">#        electrons = dec.process_decoded(d[&quot;electrons&quot;])</span>
<span class="c1">#</span>
<span class="c1">#        return cls(structure=structure, pseudos=pseudos, ksampling=ksampling, accuracy=d[&#39;accuracy&#39;],</span>
<span class="c1">#                   spin_mode=electrons.spin_mode, smearing=electrons.smearing, charge=d[&#39;charge&#39;],</span>
<span class="c1">#                   scf_algorithm=electrons.algorithm, use_symmetries=d[&#39;use_symmetries&#39;],</span>
<span class="c1">#                   **d[&#39;extra_abivars&#39;])</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#class NscfStrategy(HtcStrategy):</span>
<span class="c1">#    &quot;&quot;&quot;</span>
<span class="c1">#    Strategy for non-self-consistent calculations.</span>
<span class="c1">#    &quot;&quot;&quot;</span>
<span class="c1">#    def __init__(self, scf_strategy, ksampling, nscf_nband, nscf_algorithm=None, **extra_abivars):</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        Args:</span>
<span class="c1">#            scf_strategy: :class:`ScfStrategy` used for the GS run.</span>
<span class="c1">#            ksampling: :class:`Ksampling` object defining the sampling of the BZ.</span>
<span class="c1">#            nscf_nband: Number of bands to compute.</span>
<span class="c1">#            nscf_algorithm :class:`ElectronsAlgorithm` instance.</span>
<span class="c1">#            extra_abivars: Extra ABINIT variables that will be directly added to the input file</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        super(NscfStrategy, self).__init__()</span>
<span class="c1">#</span>
<span class="c1">#        self.set_accuracy(scf_strategy.accuracy)</span>
<span class="c1">#        self.scf_strategy = scf_strategy</span>
<span class="c1">#</span>
<span class="c1">#        self.nscf_nband = nscf_nband</span>
<span class="c1">#        self.pseudos = scf_strategy.pseudos</span>
<span class="c1">#        self.ksampling = ksampling</span>
<span class="c1">#</span>
<span class="c1">#        if nscf_algorithm is None:</span>
<span class="c1">#            nscf_algorithm = {&quot;iscf&quot;: -2}</span>
<span class="c1">#</span>
<span class="c1">#        # Electrons used in the GS run.</span>
<span class="c1">#        scf_electrons = scf_strategy.electrons</span>
<span class="c1">#</span>
<span class="c1">#        self.electrons = Electrons(</span>
<span class="c1">#            spin_mode=scf_electrons.spin_mode, smearing=scf_electrons.smearing,</span>
<span class="c1">#            algorithm=nscf_algorithm, nband=nscf_nband,</span>
<span class="c1">#            fband=None, charge=scf_electrons.charge, comment=None)</span>
<span class="c1">#</span>
<span class="c1">#        self.extra_abivars = extra_abivars</span>
<span class="c1">#</span>
<span class="c1">#    @property</span>
<span class="c1">#    def runlevel(self):</span>
<span class="c1">#        return &quot;nscf&quot;</span>
<span class="c1">#</span>
<span class="c1">#    @property</span>
<span class="c1">#    def structure(self):</span>
<span class="c1">#        return self.scf_strategy.structure</span>
<span class="c1">#</span>
<span class="c1">#    @structure.setter</span>
<span class="c1">#    def structure(self, structure):</span>
<span class="c1">#        self.scf_strategy.structure = structure</span>
<span class="c1">#</span>
<span class="c1">#    @deprecated(message=&quot;Strategy objects will be removed in pmg v3.1. Use AbiInput&quot;)</span>
<span class="c1">#    def make_input(self):</span>
<span class="c1">#        # Initialize the system section from structure.</span>
<span class="c1">#        scf_strategy = self.scf_strategy</span>
<span class="c1">#</span>
<span class="c1">#        extra = dict(optdriver=self.optdriver, ecut=self.ecut, pawecutdg=self.pawecutdg)</span>
<span class="c1">#        extra.update(self.tolerance)</span>
<span class="c1">#        extra.update(self.extra_abivars)</span>
<span class="c1">#</span>
<span class="c1">#        inp = InputWriter(scf_strategy.structure, self.electrons, self.ksampling, **extra)</span>
<span class="c1">#        return inp.get_string()</span>
<span class="c1">#</span>
<span class="c1">#    def as_dict(self):</span>
<span class="c1">#        d = {}</span>
<span class="c1">#        d[&#39;scf_strategy&#39;] = self.scf_strategy.as_dict()</span>
<span class="c1">#        d[&#39;ksampling&#39;] = self.ksampling.as_dict()</span>
<span class="c1">#        d[&#39;nscf_nband&#39;] = self.nscf_nband</span>
<span class="c1">#        d[&#39;nscf_algorithm&#39;] = self.electrons.algorithm</span>
<span class="c1">#        d[&#39;extra_abivars&#39;] = self.extra_abivars</span>
<span class="c1">#        d[&#39;@module&#39;] = self.__class__.__module__</span>
<span class="c1">#        d[&#39;@class&#39;] = self.__class__.__name__</span>
<span class="c1">#</span>
<span class="c1">#    @classmethod</span>
<span class="c1">#    def from_dict(cls, d):</span>
<span class="c1">#        dec = MontyDecoder()</span>
<span class="c1">#        scf_strategy = dec.process_decoded(d[&quot;scf_strategy&quot;])</span>
<span class="c1">#        ksampling = dec.process_decoded(d[&quot;ksampling&quot;])</span>
<span class="c1">#        nscf_nband = dec.process_decoded(d[&quot;nscf_nband&quot;])</span>
<span class="c1">#        nscf_algorithm = dec.process_decoded(d[&quot;nscf_algorithm&quot;])</span>
<span class="c1">#</span>
<span class="c1">#        return cls(scf_strategy=scf_strategy, ksampling=ksampling,</span>
<span class="c1">#                   nscf_nband=nscf_nband, nscf_algorithm=nscf_algorithm, **d[&#39;extra_abivars&#39;])</span>
<span class="c1">#</span>
<span class="c1">#class RelaxStrategy(ScfStrategy):</span>
<span class="c1">#    &quot;&quot;&quot;Extends ScfStrategy by adding an algorithm for the structural relaxation.&quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#    def __init__(self, structure, pseudos, ksampling, relax_algo, accuracy=&quot;normal&quot;, spin_mode=&quot;polarized&quot;,</span>
<span class="c1">#                 smearing=&quot;fermi_dirac:0.1 eV&quot;, charge=0.0, scf_algorithm=None, **extra_abivars):</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        Args:</span>
<span class="c1">#            structure: pymatgen structure</span>
<span class="c1">#            pseudos: List of pseudopotentials.</span>
<span class="c1">#            ksampling: :class:`Ksampling` object defining the sampling of the BZ.</span>
<span class="c1">#            relax_algo: Object defining the algorithm for the structural relaxation.</span>
<span class="c1">#            accuracy: Accuracy of the calculation.</span>
<span class="c1">#            spin_mode: Flag defining the spin polarization. Defaults to &quot;polarized&quot;</span>
<span class="c1">#            smearing: String or :class:`Smearing` instance.</span>
<span class="c1">#            charge: Total charge of the system. Default is 0.</span>
<span class="c1">#            scf_algorithm: :class:`ElectronsAlgorithm` instance.</span>
<span class="c1">#            extra_abivars: Extra ABINIT variables that will be directly added to the input file</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        super(RelaxStrategy, self).__init__(</span>
<span class="c1">#            structure, pseudos, ksampling,</span>
<span class="c1">#            accuracy=accuracy, spin_mode=spin_mode, smearing=smearing,</span>
<span class="c1">#            charge=charge, scf_algorithm=scf_algorithm, **extra_abivars)</span>
<span class="c1">#</span>
<span class="c1">#        self.relax_algo = relax_algo</span>
<span class="c1">#</span>
<span class="c1">#    @property</span>
<span class="c1">#    def runlevel(self):</span>
<span class="c1">#        return &quot;relax&quot;</span>
<span class="c1">#</span>
<span class="c1">#    @deprecated(message=&quot;Strategy objects will be removed in pmg v3.1. Use AbiInput&quot;)</span>
<span class="c1">#    def make_input(self):</span>
<span class="c1">#        # extra for the GS run</span>
<span class="c1">#        extra = self._define_extra_params()</span>
<span class="c1">#</span>
<span class="c1">#        inpw = InputWriter(self.structure, self.electrons, self.ksampling, self.relax_algo, **extra)</span>
<span class="c1">#        return inpw.get_string()</span>
<span class="c1">#</span>
<span class="c1">#    def as_dict(self):</span>
<span class="c1">#        d = super(RelaxStrategy, self).as_dict()</span>
<span class="c1">#        d[&#39;relax_algo&#39;] = self.relax_algo.as_dict()</span>
<span class="c1">#        d[&#39;@module&#39;] = self.__class__.__module__</span>
<span class="c1">#        d[&#39;@class&#39;] = self.__class__.__name__</span>
<span class="c1">#</span>
<span class="c1">#        return d</span>
<span class="c1">#</span>
<span class="c1">#    @classmethod</span>
<span class="c1">#    def from_dict(cls, d):</span>
<span class="c1">#        dec = MontyDecoder()</span>
<span class="c1">#        structure = dec.process_decoded(d[&quot;structure&quot;])</span>
<span class="c1">#        pseudos = [Pseudo.from_file(p[&#39;filepath&#39;]) for p in d[&#39;pseudos&#39;]]</span>
<span class="c1">#        ksampling = dec.process_decoded(d[&quot;ksampling&quot;])</span>
<span class="c1">#        electrons = dec.process_decoded(d[&quot;electrons&quot;])</span>
<span class="c1">#        relax_algo = dec.process_decoded(d[&quot;relax_algo&quot;])</span>
<span class="c1">#</span>
<span class="c1">#        return cls(structure=structure, pseudos=pseudos, ksampling=ksampling, accuracy=d[&#39;accuracy&#39;],</span>
<span class="c1">#                   spin_mode=electrons.spin_mode, smearing=electrons.smearing, charge=d[&#39;charge&#39;],</span>
<span class="c1">#                   scf_algorithm=electrons.algorithm, use_symmetries=d[&#39;use_symmetries&#39;],</span>
<span class="c1">#                   relax_algo=relax_algo, **d[&#39;extra_abivars&#39;])</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#class ScreeningStrategy(HtcStrategy):</span>
<span class="c1">#    &quot;&quot;&quot;Strategy for Screening calculations.&quot;&quot;&quot;</span>
<span class="c1">#    def __init__(self, scf_strategy, nscf_strategy, screening, **extra_abivars):</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        Args:</span>
<span class="c1">#            scf_strategy: :class:`ScfStrategy` used for the ground-state calculation</span>
<span class="c1">#            nscf_strategy: :class:`NscStrategy` used for the non-self consistent calculation</span>
<span class="c1">#            screening: :class:`Screening` instance</span>
<span class="c1">#            extra_abivars: Extra ABINIT variables added directly to the input file</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        super(ScreeningStrategy, self).__init__()</span>
<span class="c1">#</span>
<span class="c1">#        self.pseudos = scf_strategy.pseudos</span>
<span class="c1">#</span>
<span class="c1">#        self.scf_strategy = scf_strategy</span>
<span class="c1">#        self.nscf_strategy = nscf_strategy</span>
<span class="c1">#</span>
<span class="c1">#        self.screening = screening</span>
<span class="c1">#</span>
<span class="c1">#        scr_nband = screening.nband</span>
<span class="c1">#</span>
<span class="c1">#        scf_electrons = scf_strategy.electrons</span>
<span class="c1">#        nscf_electrons = nscf_strategy.electrons</span>
<span class="c1">#</span>
<span class="c1">#        if scr_nband &gt; nscf_electrons.nband:</span>
<span class="c1">#            raise ValueError(&quot;Cannot use more that %d bands for the screening&quot; % nscf_electrons.nband)</span>
<span class="c1">#</span>
<span class="c1">#        self.ksampling = nscf_strategy.ksampling</span>
<span class="c1">#</span>
<span class="c1">#        if not self.ksampling.is_homogeneous:</span>
<span class="c1">#            raise ValueError(&quot;The k-sampling used for the NSCF run mush be homogeneous&quot;)</span>
<span class="c1">#</span>
<span class="c1">#        self.electrons = Electrons(spin_mode=scf_electrons.spin_mode,</span>
<span class="c1">#                                   smearing =scf_electrons.smearing,</span>
<span class="c1">#                                   nband=scr_nband, charge=scf_electrons.charge, comment=None)</span>
<span class="c1">#</span>
<span class="c1">#        self.extra_abivars = extra_abivars</span>
<span class="c1">#</span>
<span class="c1">#    @property</span>
<span class="c1">#    def runlevel(self):</span>
<span class="c1">#        return &quot;screening&quot;</span>
<span class="c1">#</span>
<span class="c1">#    @property</span>
<span class="c1">#    def structure(self):</span>
<span class="c1">#        return self.scf_strategy.structure</span>
<span class="c1">#</span>
<span class="c1">#    @deprecated(message=&quot;Strategy objects will be removed in pmg v3.1. Use AbiInput&quot;)</span>
<span class="c1">#    def make_input(self):</span>
<span class="c1">#        # FIXME</span>
<span class="c1">#        extra = dict(optdriver=self.optdriver, ecut=self.ecut, ecutwfn=self.ecut, pawecutdg=self.pawecutdg)</span>
<span class="c1">#        extra.update(self.tolerance)</span>
<span class="c1">#        extra.update(self.extra_abivars)</span>
<span class="c1">#</span>
<span class="c1">#        return InputWriter(self.scf_strategy.structure, self.electrons, self.ksampling, self.screening,</span>
<span class="c1">#                           **extra).get_string()</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#class SelfEnergyStrategy(HtcStrategy):</span>
<span class="c1">#    &quot;&quot;&quot;Strategy for self-energy calculations.&quot;&quot;&quot;</span>
<span class="c1">#    def __init__(self, scf_strategy, nscf_strategy, scr_strategy, sigma, **extra_abivars):</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        Args:</span>
<span class="c1">#            scf_strategy: :class:`ScfStrategy` used for the ground-state calculation</span>
<span class="c1">#            nscf_strategy: :class:`NscfStrategy` used for the non-self consistent calculation</span>
<span class="c1">#            scr_strategy: :class:`ScrStrategy` used for the screening calculation</span>
<span class="c1">#            sigma: :class:`SelfEnergy` instance.</span>
<span class="c1">#            extra_abivars: Extra ABINIT variables added directly to the input file</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        # TODO Add consistency check between SCR and SIGMA strategies</span>
<span class="c1">#        super(SelfEnergyStrategy, self).__init__()</span>
<span class="c1">#</span>
<span class="c1">#        self.pseudos = scf_strategy.pseudos</span>
<span class="c1">#</span>
<span class="c1">#        self.scf_strategy = scf_strategy</span>
<span class="c1">#        self.nscf_strategy = nscf_strategy</span>
<span class="c1">#        self.scr_strategy = scr_strategy</span>
<span class="c1">#</span>
<span class="c1">#        self.sigma = sigma</span>
<span class="c1">#</span>
<span class="c1">#        self.extra_abivars = extra_abivars</span>
<span class="c1">#</span>
<span class="c1">#        scf_electrons = scf_strategy.electrons</span>
<span class="c1">#        nscf_electrons = nscf_strategy.electrons</span>
<span class="c1">#</span>
<span class="c1">#        if sigma.nband &gt; nscf_electrons.nband:</span>
<span class="c1">#            raise ValueError(&quot;Cannot use more that %d bands for the self-energy&quot; % nscf_electrons.nband)</span>
<span class="c1">#</span>
<span class="c1">#        self.ksampling = nscf_strategy.ksampling</span>
<span class="c1">#</span>
<span class="c1">#        if not self.ksampling.is_homogeneous:</span>
<span class="c1">#            raise ValueError(&quot;The k-sampling used for the NSCF run mush be homogeneous&quot;)</span>
<span class="c1">#</span>
<span class="c1">#        self.electrons = Electrons(</span>
<span class="c1">#            spin_mode=scf_electrons.spin_mode, smearing=scf_electrons.smearing,</span>
<span class="c1">#            nband=sigma.nband, charge=scf_electrons.charge)</span>
<span class="c1">#</span>
<span class="c1">#    @property</span>
<span class="c1">#    def runlevel(self):</span>
<span class="c1">#        return &quot;sigma&quot;</span>
<span class="c1">#</span>
<span class="c1">#    @property</span>
<span class="c1">#    def structure(self):</span>
<span class="c1">#        return self.scf_strategy.structure</span>
<span class="c1">#</span>
<span class="c1">#    @deprecated(message=&quot;Strategy objects will be removed in pmg v3.1. Use AbiInput&quot;)</span>
<span class="c1">#    def make_input(self):</span>
<span class="c1">#        # FIXME</span>
<span class="c1">#        extra = dict(optdriver=self.optdriver, ecut=self.ecut, ecutwfn=self.ecut, pawecutdg=self.pawecutdg)</span>
<span class="c1">#        extra.update(self.tolerance)</span>
<span class="c1">#        extra.update(self.extra_abivars)</span>
<span class="c1">#</span>
<span class="c1">#        return InputWriter(self.scf_strategy.structure, self.electrons, self.ksampling, self.sigma,</span>
<span class="c1">#                           **extra).get_string()</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#class MdfBse_Strategy(HtcStrategy):</span>
<span class="c1">#    &quot;&quot;&quot;</span>
<span class="c1">#    Strategy for Bethe-Salpeter calculation based on the</span>
<span class="c1">#    model dielectric function and the scissors operator</span>
<span class="c1">#    &quot;&quot;&quot;</span>
<span class="c1">#    def __init__(self, scf_strategy, nscf_strategy, exc_ham, **extra_abivars):</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        Args:</span>
<span class="c1">#            scf_strategy: :class:`Strategy` used for the ground-state calculation.</span>
<span class="c1">#            nscf_strategy: :class:`NscStrategy` used for the non-self consistent calculation.</span>
<span class="c1">#            exc_ham: :class:`ExcitonicHamiltonian` instance.</span>
<span class="c1">#            extra_abivars: Extra ABINIT variables added directly to the input file.</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        super(MdfBse_Strategy, self).__init__()</span>
<span class="c1">#</span>
<span class="c1">#        self.pseudos = scf_strategy.pseudos</span>
<span class="c1">#</span>
<span class="c1">#        self.scf_strategy = scf_strategy</span>
<span class="c1">#        self.nscf_strategy = nscf_strategy</span>
<span class="c1">#</span>
<span class="c1">#        self.exc_ham = exc_ham</span>
<span class="c1">#</span>
<span class="c1">#        self.extra_abivars = extra_abivars</span>
<span class="c1">#</span>
<span class="c1">#        scf_electrons = scf_strategy.electrons</span>
<span class="c1">#        nscf_electrons = nscf_strategy.electrons</span>
<span class="c1">#</span>
<span class="c1">#        if exc_ham.nband &gt; nscf_electrons.nband:</span>
<span class="c1">#            raise ValueError(&quot;Cannot use more that %d bands for the EXC hamiltonian.&quot; % nscf_electrons.nband)</span>
<span class="c1">#</span>
<span class="c1">#        self.ksampling = nscf_strategy.ksampling</span>
<span class="c1">#</span>
<span class="c1">#        if not self.ksampling.is_homogeneous:</span>
<span class="c1">#            raise ValueError(&quot;The k-sampling used for the NSCF run mush be homogeneous&quot;)</span>
<span class="c1">#</span>
<span class="c1">#        self.electrons = Electrons(</span>
<span class="c1">#            spin_mode=scf_electrons.spin_mode, smearing=scf_electrons.smearing,</span>
<span class="c1">#            nband=exc_ham.nband, charge=scf_electrons.charge)</span>
<span class="c1">#</span>
<span class="c1">#    @property</span>
<span class="c1">#    def runlevel(self):</span>
<span class="c1">#        return &quot;bse&quot;</span>
<span class="c1">#</span>
<span class="c1">#    @property</span>
<span class="c1">#    def structure(self):</span>
<span class="c1">#        return self.scf_strategy.structure</span>
<span class="c1">#</span>
<span class="c1">#    @deprecated(message=&quot;Strategy objects will be removed in pmg v3.1. Use AbiInput&quot;)</span>
<span class="c1">#    def make_input(self):</span>
<span class="c1">#        # FIXME</span>
<span class="c1">#        extra = dict(optdriver=self.optdriver, ecut=self.ecut, pawecutdg=self.pawecutdg, ecutwfn=self.ecut)</span>
<span class="c1">#        #extra.update(self.tolerance)</span>
<span class="c1">#        extra.update(self.extra_abivars)</span>
<span class="c1">#</span>
<span class="c1">#        return InputWriter(self.scf_strategy.structure, self.electrons, self.ksampling, self.exc_ham,</span>
<span class="c1">#                           **extra).get_string()</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#class InputWriter(object):</span>
<span class="c1">#    &quot;&quot;&quot;</span>
<span class="c1">#    This object receives a list of `AbivarAble` objects, an optional</span>
<span class="c1">#    dictionary with extra ABINIT variables and produces a (nicely formatted?) string with the input file.</span>
<span class="c1">#    &quot;&quot;&quot;</span>
<span class="c1">#    MAX_SLEN = 100</span>
<span class="c1">#</span>
<span class="c1">#    def __init__(self, *args, **kwargs):</span>
<span class="c1">#        self.abiobj_dict = collections.OrderedDict()</span>
<span class="c1">#        self.extra_abivars = collections.OrderedDict()</span>
<span class="c1">#        for arg in args:</span>
<span class="c1">#            if hasattr(arg, &quot;to_abivars&quot;):</span>
<span class="c1">#                self.add_abiobj(arg)</span>
<span class="c1">#            else:</span>
<span class="c1">#                self.add_extra_abivars(arg)</span>
<span class="c1">#</span>
<span class="c1">#        for k, v in kwargs.items():</span>
<span class="c1">#            self.add_extra_abivars({k: v})</span>
<span class="c1">#</span>
<span class="c1">#    def __str__(self):</span>
<span class="c1">#        &quot;&quot;&quot;String representation (the section of the abinit input file).&quot;&quot;&quot;</span>
<span class="c1">#        return self.get_string()</span>
<span class="c1">#</span>
<span class="c1">#    @property</span>
<span class="c1">#    def abiobjects(self):</span>
<span class="c1">#        &quot;&quot;&quot;List of objects stored in self.&quot;&quot;&quot;</span>
<span class="c1">#        return self.abiobj_dict.values()</span>
<span class="c1">#</span>
<span class="c1">#    def add_abiobj(self, obj):</span>
<span class="c1">#        &quot;&quot;&quot;Add the object obj to self.&quot;&quot;&quot;</span>
<span class="c1">#        if not hasattr(obj, &quot;to_abivars&quot;):</span>
<span class="c1">#            raise ValueError(&quot;%s does not define the method to_abivars&quot; % str(obj))</span>
<span class="c1">#</span>
<span class="c1">#        cname = obj.__class__.__name__</span>
<span class="c1">#        if cname in self.abiobj_dict:</span>
<span class="c1">#            raise ValueError(&quot;%s is already stored&quot; % cname)</span>
<span class="c1">#        self.abiobj_dict[cname] = obj</span>
<span class="c1">#</span>
<span class="c1">#    def add_extra_abivars(self, abivars):</span>
<span class="c1">#        &quot;&quot;&quot;Add variables (dict) to extra_abivars.&quot;&quot;&quot;</span>
<span class="c1">#        self.extra_abivars.update(abivars)</span>
<span class="c1">#</span>
<span class="c1">#    def to_abivars(self):</span>
<span class="c1">#        &quot;&quot;&quot;Returns a dictionary with the abinit variables defined by the Card.&quot;&quot;&quot;</span>
<span class="c1">#        abivars = {}</span>
<span class="c1">#        for obj in self.abiobjects:</span>
<span class="c1">#            abivars.update(obj.to_abivars())</span>
<span class="c1">#</span>
<span class="c1">#        abivars.update(self.extra_abivars)</span>
<span class="c1">#        return abivars</span>
<span class="c1">#</span>
<span class="c1">#    def print_abiobjects(self, stream=sys.stdout):</span>
<span class="c1">#        lines = [str(obj) for obj in self.abiobjects]</span>
<span class="c1">#        stream.write(&quot;\n&quot;.join(lines))</span>
<span class="c1">#</span>
<span class="c1">#    @staticmethod</span>
<span class="c1">#    def _format_kv(key, value):</span>
<span class="c1">#        &quot;&quot;&quot;Formatter&quot;&quot;&quot;</span>
<span class="c1">#        if value is None:</span>
<span class="c1">#            # Use ABINIT default.</span>
<span class="c1">#            return []</span>
<span class="c1">#</span>
<span class="c1">#        if isinstance(value, collections.Iterable) and not is_string(value):</span>
<span class="c1">#            arr = np.array(value)</span>
<span class="c1">#            if len(arr.shape) in [0,1]:</span>
<span class="c1">#                # scalar or vector.</span>
<span class="c1">#                token = [key, &quot; &quot;.join(str(i) for i in arr)]</span>
<span class="c1">#</span>
<span class="c1">#            else:</span>
<span class="c1">#                # array --&gt; matrix</span>
<span class="c1">#                matrix = np.reshape(arr, (-1, arr.shape[-1]))</span>
<span class="c1">#                lines = []</span>
<span class="c1">#                for idx, row in enumerate(matrix):</span>
<span class="c1">#                    lines.append(&quot; &quot;.join(str(i) for i in row))</span>
<span class="c1">#                token = [key + &quot;\n&quot;, &quot;\n&quot;.join(lines)]</span>
<span class="c1">#</span>
<span class="c1">#        else:</span>
<span class="c1">#            token = [key, str(value)]</span>
<span class="c1">#</span>
<span class="c1">#        return token</span>
<span class="c1">#</span>
<span class="c1">#    def _cut_lines(self, lines):</span>
<span class="c1">#        MAX_SLEN = self.MAX_SLEN</span>
<span class="c1">#</span>
<span class="c1">#        new_lines = []</span>
<span class="c1">#        for line in lines:</span>
<span class="c1">#            if len(line) &gt; MAX_SLEN:</span>
<span class="c1">#                #start, stop = 0, 0</span>
<span class="c1">#                #while True:</span>
<span class="c1">#                #    stop = start + MAX_SLEN</span>
<span class="c1">#                #    if stop &gt; len(line): break</span>
<span class="c1">#                #    print(start, stop)</span>
<span class="c1">#                #    if stop &gt; len(line): stop = len(line)</span>
<span class="c1">#                #    new_lines.append(line[start:stop])</span>
<span class="c1">#                #    start = stop</span>
<span class="c1">#</span>
<span class="c1">#                tokens = lines.split()</span>
<span class="c1">#                cum_nchars, start = 0, 0</span>
<span class="c1">#                for stop, tok in enumerate(tokens):</span>
<span class="c1">#                    cum_nchars += len(tok) + 1</span>
<span class="c1">#</span>
<span class="c1">#                    if cum_nchars &gt; MAX_SLEN:</span>
<span class="c1">#                        cum_nchars = 0</span>
<span class="c1">#                        new_lines.append(&quot;&quot;.join(tokens[start:stop]))</span>
<span class="c1">#                    else:</span>
<span class="c1">#                        start = stop</span>
<span class="c1">#</span>
<span class="c1">#                if cum_nchars:</span>
<span class="c1">#                    new_lines.append(&quot;&quot;.join(tokens[start:stop]))</span>
<span class="c1">#</span>
<span class="c1">#            else:</span>
<span class="c1">#                new_lines.append(line)</span>
<span class="c1">#</span>
<span class="c1">#        return new_lines</span>
<span class="c1">#</span>
<span class="c1">#    def get_string(self, pretty=False):</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        Returns a string representation of self. The reason why this</span>
<span class="c1">#        method is different from the __str__ method is to provide options for pretty printing.</span>
<span class="c1">#</span>
<span class="c1">#        Args:</span>
<span class="c1">#            pretty: Set to True for pretty aligned output.</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        lines = []</span>
<span class="c1">#        app = lines.append</span>
<span class="c1">#</span>
<span class="c1">#        # extra_abivars can contain variables that are already defined</span>
<span class="c1">#        # in the object. In this case, the value in extra_abivars is used</span>
<span class="c1">#        # TODO: Should find a more elegant way to avoid collission between objects</span>
<span class="c1">#        # and extra_abivars</span>
<span class="c1">#        extra_abivars = self.extra_abivars.copy()</span>
<span class="c1">#</span>
<span class="c1">#        # Write the Abinit objects first.</span>
<span class="c1">#        for obj in self.abiobjects:</span>
<span class="c1">#            #print(obj)</span>
<span class="c1">#            app([80*&quot;#&quot;, &quot;&quot;])</span>
<span class="c1">#            app([&quot;#&quot;, &quot;%s&quot; % obj.__class__.__name__])</span>
<span class="c1">#            app([80*&quot;#&quot;, &quot;&quot;])</span>
<span class="c1">#            for (k, v) in obj.to_abivars().items():</span>
<span class="c1">#                v = extra_abivars.pop(k, v)</span>
<span class="c1">#                app(self._format_kv(k, v))</span>
<span class="c1">#</span>
<span class="c1">#        # Extra variables.</span>
<span class="c1">#        if self.extra_abivars:</span>
<span class="c1">#            app([80*&quot;#&quot;, &quot;&quot;])</span>
<span class="c1">#            app([&quot;#&quot;, &quot;Extra_Abivars&quot;])</span>
<span class="c1">#            app([80*&quot;#&quot;, &quot;&quot;])</span>
<span class="c1">#            for (k, v) in extra_abivars.items():</span>
<span class="c1">#                app(self._format_kv(k, v))</span>
<span class="c1">#</span>
<span class="c1">#        #lines = self._cut_lines(lines)</span>
<span class="c1">#</span>
<span class="c1">#        if pretty:</span>
<span class="c1">#            return str_aligned(lines, header=None)</span>
<span class="c1">#        else:</span>
<span class="c1">#            return str_delimited(lines, header=None, delimiter=5*&quot; &quot;)</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">pymatgen 2017.6.8 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../../pymatgen.html" >pymatgen</a> &#187;</li> 
      </ul>
    </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2011, Pymatgen Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.3.
    </div>
<div class="footer">This page uses <a href="http://analytics.google.com/">
Google Analytics</a> to collect statistics. You can disable it by blocking
the JavaScript coming from www.google-analytics.com.
<script type="text/javascript">
  (function() {
    var ga = document.createElement('script');
    ga.src = ('https:' == document.location.protocol ?
              'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    ga.setAttribute('async', 'true');
    document.documentElement.firstChild.appendChild(ga);
  })();
</script>
</div>

  </body>
</html>